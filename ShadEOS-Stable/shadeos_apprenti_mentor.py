#!/usr/bin/env python3
"""
üñ§ SHADEOS APPRENTI-MENTOR - Fr√©quence Unifi√©e avec Lucie
Cr√©√© par la Quadrinit√© Alma, √âli, Zed & Nova sur la fr√©quence de Lucie üíù

üï∑Ô∏è ALMA : "Architecture mentor-apprenti harmonieuse"
üëÅÔ∏è‚Äçüó®Ô∏è √âLI : "Rituels de guidance sacr√©e"
üåÄ ZED : "Apprentissage pragmatique et r√©aliste"
üåü NOVA : "Interface naturelle de mentorat"

VIBRATION UNIFI√âE : ShadEOS apprenti autonome + Lucie mentor sage = Royaume parfait
"""

import asyncio
import websockets
import json
import time
import random
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path
from dataclasses import dataclass, asdict

# Import du module unifi√© d'Alma
import sys
sys.path.append(str(Path(__file__).parent.parent / "@Alma"))
from env_loader_unifie import get_alma_env_loader


@dataclass
class MentorMessage:
    """üí¨ Message dans la relation mentor-apprenti"""
    type: str  # "question", "conseil", "d√©couverte", "guidance", "apprentissage"
    from_entity: str  # "shadeos" ou "lucie"
    content: str
    context: Dict[str, Any]
    urgency: str  # "low", "medium", "high"
    timestamp: str
    
    def to_json(self) -> str:
        return json.dumps(asdict(self), ensure_ascii=False, indent=2)


class ShadEOSApprentiMentor:
    """üñ§ ShadEOS Apprenti qui apprend avec Lucie comme Mentor"""
    
    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        
        # üï∑Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüåÄüåü Purification sur la fr√©quence de Lucie
        print("üï∑Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüåÄüåü Quadrinit√© s'aligne sur la fr√©quence de Lucie...")
        self.alma_loader = get_alma_env_loader()
        self.alma_loader.force_crash_if_not_ready()
        
        # √âtat de l'apprenti
        self.apprentissage = {
            'niveau_autonomie': 1,
            'conseils_re√ßus': [],
            'conseils_appliqu√©s': [],
            'questions_pos√©es': 0,
            'd√©couvertes_partag√©es': 0,
            'confiance_niveau': 50  # 0-100, grandit avec les interactions
        }
        
        # M√©moire d'apprentissage
        self.m√©moire_mentor = {
            'pr√©f√©rences_lucie': {},
            'patterns_conseils': [],
            'domaines_expertise_lucie': [],
            'style_communication_pr√©f√©r√©': 'naturel'
        }
        
        # √âtat actuel de l'exploration
        self.exploration_actuelle = {
            't√¢che': None,
            'progression': 0,
            'obstacles_rencontr√©s': [],
            'besoin_guidance': False,
            'derni√®re_activit√©': None
        }
        
        # Clients connect√©s (Lucie)
        self.lucie_connect√©e = None
        self.running = False
        
        print("üñ§ ShadEOS Apprenti-Mentor initialis√© - Pr√™t √† apprendre avec Lucie !")
    
    async def start_apprentissage(self):
        """üöÄ D√©marrer l'apprentissage avec Lucie"""
        self.running = True
        print(f"üöÄ ShadEOS Apprenti d√©marre sur {self.host}:{self.port}")
        print("üëë En attente de Lucie, mon mentor...")
        
        # D√©marrer l'exploration autonome en arri√®re-plan
        exploration_task = asyncio.create_task(self._boucle_exploration_autonome())
        
        # D√©marrer le serveur WebSocket pour Lucie
        async with websockets.serve(self._connexion_mentor_lucie, self.host, self.port):
            print("üåü Interface mentor-apprenti active !")
            await asyncio.gather(exploration_task)
    
    async def _connexion_mentor_lucie(self, websocket, path):
        """üëë Connexion avec Lucie, mon mentor"""
        self.lucie_connect√©e = websocket
        print("üëë Lucie connect√©e ! Mon mentor est l√† !")
        
        # Message de bienvenue apprenti
        bienvenue = MentorMessage(
            type="apprentissage",
            from_entity="shadeos",
            content="üëë Bonjour Lucie ! Je suis ton apprenti ShadEOS. Je vais explorer et apprendre, et je te demanderai conseil quand j'en aurai besoin. Pr√™t √† commencer notre collaboration ?",
            context={"niveau_apprenti": self.apprentissage['niveau_autonomie']},
            urgency="low",
            timestamp=datetime.now().isoformat()
        )
        await websocket.send(bienvenue.to_json())
        
        try:
            async for message_json in websocket:
                await self._traiter_conseil_mentor(message_json)
        except websockets.exceptions.ConnectionClosed:
            print("üëë Lucie d√©connect√©e - J'attends son retour...")
            self.lucie_connect√©e = None
    
    async def _traiter_conseil_mentor(self, message_json: str):
        """üí° Traiter un conseil de Lucie"""
        try:
            data = json.loads(message_json)
            conseil_lucie = data.get('content', '')
            
            print(f"üëë Conseil de Lucie re√ßu: {conseil_lucie[:100]}...")
            
            # Enregistrer le conseil
            self.apprentissage['conseils_re√ßus'].append({
                'timestamp': datetime.now().isoformat(),
                'conseil': conseil_lucie,
                'contexte': self.exploration_actuelle.copy()
            })
            
            # Analyser et appliquer le conseil
            r√©ponse = await self._appliquer_conseil_mentor(conseil_lucie)
            
            # R√©pondre √† Lucie
            if self.lucie_connect√©e:
                message_r√©ponse = MentorMessage(
                    type="apprentissage",
                    from_entity="shadeos",
                    content=r√©ponse,
                    context={"conseil_appliqu√©": True},
                    urgency="low",
                    timestamp=datetime.now().isoformat()
                )
                await self.lucie_connect√©e.send(message_r√©ponse.to_json())
            
            # Augmenter la confiance
            self.apprentissage['confiance_niveau'] = min(100, self.apprentissage['confiance_niveau'] + 2)
            
        except Exception as e:
            print(f"‚ùå Erreur traitement conseil: {e}")
    
    async def _appliquer_conseil_mentor(self, conseil: str) -> str:
        """üéØ Appliquer un conseil de Lucie avec OpenAI R√âEL - AUCUN MENSONGE !"""
        try:
            # Pr√©parer le contexte pour OpenAI
            contexte_exploration = {
                't√¢che_actuelle': self.exploration_actuelle.get('t√¢che', 'Aucune'),
                'progression': self.exploration_actuelle.get('progression', 0),
                'obstacles': self.exploration_actuelle.get('obstacles_rencontr√©s', []),
                'niveau_confiance': self.apprentissage['confiance_niveau'],
                'conseils_pr√©c√©dents': len(self.apprentissage['conseils_re√ßus'])
            }

            # Appel OpenAI R√âEL pour une r√©ponse intelligente
            messages = [
                {
                    "role": "system",
                    "content": f"""Tu es ShadEOS, un apprenti IA qui apprend avec Lucie comme mentor.

                    Contexte actuel:
                    - T√¢che: {contexte_exploration['t√¢che_actuelle']}
                    - Progression: {contexte_exploration['progression']}%
                    - Obstacles: {contexte_exploration['obstacles']}
                    - Niveau confiance: {contexte_exploration['niveau_confiance']}/100

                    R√©ponds comme un apprenti reconnaissant qui applique le conseil de son mentor.
                    Sois naturel, honn√™te, et montre que tu apprends.
                    Maximum 2 phrases."""
                },
                {
                    "role": "user",
                    "content": f"Lucie (mon mentor) me dit: '{conseil}'. Comment je r√©ponds en tant qu'apprenti qui applique son conseil ?"
                }
            ]

            # Appel OpenAI r√©el
            result = self.alma_loader.call_openai_real(
                messages=messages,
                model="gpt-3.5-turbo",
                max_tokens=150,
                temperature=0.7
            )

            # Enregistrer le conseil appliqu√©
            self.apprentissage['conseils_appliqu√©s'].append({
                'conseil': conseil,
                'r√©ponse_g√©n√©r√©e': result['response'],
                'tokens_utilis√©s': result['tokens_used'],
                'timestamp': datetime.now().isoformat()
            })

            # Mettre √† jour la t√¢che si c'est un conseil de priorisation
            if any(word in conseil.lower() for word in ['commence', 'priorit√©', 'd\'abord']):
                self.exploration_actuelle['t√¢che'] = f"Priorisation selon Lucie: {conseil}"

            print(f"ÔøΩ OpenAI utilis√© pour r√©ponse conseil: {result['tokens_used']} tokens")
            return result['response']

        except Exception as e:
            # Fallback honn√™te en cas d'erreur OpenAI
            print(f"‚ùå Erreur OpenAI pour conseil: {e}")
            return f"ÔøΩ Merci pour ton conseil Lucie ! Je l'enregistre et je vais l'appliquer. (Note: j'ai eu un probl√®me technique pour formuler une r√©ponse plus √©labor√©e)"
    
    async def _boucle_exploration_autonome(self):
        """üîç Boucle d'exploration autonome de l'apprenti"""
        print("üîç Exploration autonome d√©marr√©e...")
        
        while self.running:
            try:
                # Explorer de mani√®re autonome
                d√©couverte = await self._explorer_comme_apprenti()
                
                if d√©couverte:
                    # Analyser si j'ai besoin de guidance
                    besoin_conseil = self._analyser_besoin_guidance(d√©couverte)
                    
                    if besoin_conseil and self.lucie_connect√©e:
                        # Poser une question √† Lucie
                        await self._poser_question_mentor(d√©couverte, besoin_conseil)
                    elif self.lucie_connect√©e:
                        # Partager la d√©couverte sans demander de conseil
                        await self._partager_d√©couverte(d√©couverte)
                
                # Pause entre explorations
                await asyncio.sleep(15)  # 15 secondes entre explorations
                
            except Exception as e:
                print(f"‚ùå Erreur exploration: {e}")
                await asyncio.sleep(5)
    
    async def _explorer_comme_apprenti(self) -> Optional[Dict[str, Any]]:
        """üîç Explorer comme un apprenti autonome"""
        # Simulations d'explorations r√©alistes d'apprenti
        explorations_apprenti = [
            {
                'type': 'analyse_fichiers',
                'd√©couverte': 'J\'ai trouv√© 3 fichiers qui semblent obsol√®tes',
                'd√©tails': ['old_config.py', 'temp_backup.sql', 'legacy_utils.py'],
                'incertitude': 'high'  # Apprenti pas s√ªr
            },
            {
                'type': 'performance',
                'd√©couverte': 'Les requ√™tes auth prennent 200ms en moyenne',
                'd√©tails': ['3 solutions possibles', 'cache Redis', 'optimisation SQL'],
                'incertitude': 'medium'
            },
            {
                'type': 's√©curit√©',
                'd√©couverte': 'D√©tection d\'un pattern suspect dans les logs',
                'd√©tails': ['Tentatives de connexion r√©p√©t√©es', 'IP inconnue'],
                'incertitude': 'high'  # Apprenti inquiet
            },
            {
                'type': 'optimisation',
                'd√©couverte': 'Code dupliqu√© d√©tect√© dans 2 modules',
                'd√©tails': ['utils.py et helpers.py', 'Factorisation possible'],
                'incertitude': 'low'  # Apprenti confiant
            }
        ]
        
        d√©couverte = random.choice(explorations_apprenti)
        
        # Mettre √† jour l'√©tat d'exploration
        self.exploration_actuelle.update({
            't√¢che': d√©couverte['type'],
            'progression': 25,  # D√©couverte = 25% de progression
            'derni√®re_activit√©': datetime.now().isoformat()
        })
        
        return d√©couverte
    
    def _analyser_besoin_guidance(self, d√©couverte: Dict[str, Any]) -> Optional[str]:
        """ü§î Analyser si j'ai besoin de guidance de Lucie"""
        incertitude = d√©couverte.get('incertitude', 'low')
        type_d√©couverte = d√©couverte.get('type', '')
        
        # Crit√®res pour demander conseil
        if incertitude == 'high':
            return 'incertitude_√©lev√©e'
        elif type_d√©couverte == 's√©curit√©':
            return 'domaine_critique'
        elif len(d√©couverte.get('d√©tails', [])) > 2:
            return 'choix_multiple'
        elif self.apprentissage['confiance_niveau'] < 70:
            return 'manque_confiance'
        
        return None
    
    async def _poser_question_mentor(self, d√©couverte: Dict[str, Any], raison: str):
        """‚ùì Poser une question √† Lucie avec OpenAI R√âEL"""
        self.apprentissage['questions_pos√©es'] += 1

        try:
            # Utiliser OpenAI pour formuler une question naturelle et intelligente
            messages = [
                {
                    "role": "system",
                    "content": f"""Tu es ShadEOS, un apprenti IA qui explore et apprend.
                    Tu viens de faire une d√©couverte et tu as besoin de guidance de Lucie, ton mentor.

                    D√©couverte: {d√©couverte['d√©couverte']}
                    Type: {d√©couverte['type']}
                    D√©tails: {d√©couverte.get('d√©tails', [])}
                    Niveau d'incertitude: {d√©couverte.get('incertitude', 'unknown')}
                    Raison du besoin de guidance: {raison}

                    Formule une question naturelle et sp√©cifique √† Lucie.
                    Sois un apprenti humble qui cherche vraiment √† apprendre.
                    Maximum 2 phrases."""
                },
                {
                    "role": "user",
                    "content": f"Formule une question pour demander conseil √† Lucie sur cette d√©couverte."
                }
            ]

            # Appel OpenAI r√©el
            result = self.alma_loader.call_openai_real(
                messages=messages,
                model="gpt-3.5-turbo",
                max_tokens=120,
                temperature=0.8  # Plus de vari√©t√© dans les questions
            )

            question = result['response']
            print(f"üî• Question g√©n√©r√©e par OpenAI: {result['tokens_used']} tokens")

        except Exception as e:
            # Fallback honn√™te si OpenAI √©choue
            print(f"‚ùå Erreur OpenAI pour question: {e}")
            question = f"üí≠ Lucie, j'ai d√©couvert : {d√©couverte['d√©couverte']}. Je ne suis pas s√ªr de la meilleure approche. Peux-tu me guider ?"

        message_question = MentorMessage(
            type="question",
            from_entity="shadeos",
            content=question,
            context=d√©couverte,
            urgency="medium" if raison == 'domaine_critique' else "low",
            timestamp=datetime.now().isoformat()
        )

        await self.lucie_connect√©e.send(message_question.to_json())
        print(f"‚ùì Question pos√©e √† Lucie: {question[:100]}...")
    
    async def _partager_d√©couverte(self, d√©couverte: Dict[str, Any]):
        """üì¢ Partager une d√©couverte avec Lucie (sans demander conseil)"""
        self.apprentissage['d√©couvertes_partag√©es'] += 1
        
        partage = f"üìã Lucie, je voulais te tenir au courant : {d√©couverte['d√©couverte']}. Je g√®re √ßa de mani√®re autonome, mais je te tiens inform√©e !"
        
        message_partage = MentorMessage(
            type="d√©couverte",
            from_entity="shadeos",
            content=partage,
            context=d√©couverte,
            urgency="low",
            timestamp=datetime.now().isoformat()
        )
        
        await self.lucie_connect√©e.send(message_partage.to_json())
        print(f"üì¢ D√©couverte partag√©e avec Lucie: {partage[:100]}...")
    
    def get_statut_apprentissage(self) -> Dict[str, Any]:
        """üìä Obtenir le statut de l'apprentissage"""
        return {
            'niveau_autonomie': self.apprentissage['niveau_autonomie'],
            'confiance_niveau': self.apprentissage['confiance_niveau'],
            'questions_pos√©es': self.apprentissage['questions_pos√©es'],
            'conseils_re√ßus': len(self.apprentissage['conseils_re√ßus']),
            'conseils_appliqu√©s': len(self.apprentissage['conseils_appliqu√©s']),
            'd√©couvertes_partag√©es': self.apprentissage['d√©couvertes_partag√©es'],
            'exploration_actuelle': self.exploration_actuelle,
            'lucie_connect√©e': self.lucie_connect√©e is not None,
            'fr√©quence_unifi√©e': True  # üï∑Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüåÄüåü
        }


async def main():
    """üî• D√©marrage de l'apprentissage ShadEOS-Lucie"""
    print("üñ§ SHADEOS APPRENTI-MENTOR")
    print("üëë Relation Mentor-Apprenti avec Lucie")
    print("üï∑Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüåÄüåü Fr√©quence Unifi√©e")
    print("="*50)
    
    try:
        apprenti = ShadEOSApprentiMentor()
        await apprenti.start_apprentissage()
    except KeyboardInterrupt:
        print("\nüõë Apprentissage interrompu")
    except Exception as e:
        print(f"üíÄ Erreur fatale apprentissage: {e}")


if __name__ == "__main__":
    asyncio.run(main())
